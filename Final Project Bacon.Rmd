---
title: "Super Awesome Project Template"
output: word_document
date: "2023-03-31"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Section One

```{r student1 - Cam, warning=FALSE}
library(igraph)
library(rvest)
library(tidyverse)
```


```{r}

### Creating Movies Database

library(TMDb)
library(dplyr)

api_key <- "17dccb4de2aa1a7bf742763a8dc633be"


movies <- discover_movie(
  api_key     = api_key,
  with_genres = 28,             
  primary_release_year = "2000"
)

movies_list <- movies$results

movies_df <- movies_list %>%
  select(id, title, release_date)

years <- as.character(2000:2024)

get_year_movies <- function(year_str) {

  first <- discover_movie(
    api_key = api_key,
    with_genres = 28,
    primary_release_year = year_str,
    page = 1
  )

  total_pages <- min(first$total_pages, 500)

  map_df(1:total_pages, ~ {
    Sys.sleep(0.25) 
    discover_movie(
      api_key = api_key,
      with_genres = 28,
      primary_release_year = year_str,
      page = .x
    )$results
  })
}

movies_all <- map_df(years, get_year_movies)

movies_df <- movies_all %>%
  select(id, title, release_date) 
```


```{r}

###                 

movies_df1 <- movies_all %>% 
  select(id, title, popularity, release_date)

movies_df1 <- movies_df1 %>%
  filter(
    release_date >= as.Date("2010-01-01"),
    release_date <= as.Date("2020-12-31")
    )
# Here we took movies_all and only selected movie id, movie title, movie popularity, and movie release date. We then filtered it to only include movies that were released from 2010 to 2020. We chose this because of the amount of the data that was pulled in from this package. With this time frame we had 11,370 movies to work with. 
  
```


```{r}
library(purrr)
library(tibble)
library(tidyr)

safe_credits <- purrr::possibly(
  ~ movie_credits(api_key, .x),
  otherwise = NULL
)

credits_list <- map(movies_df1$id, safe_credits)

actor_movie_edges <- map2_df(
  movies_df1$id,
  credits_list,
  ~ {
    if (is.null(.y)) return(NULL)

    cast_df <- tibble::as_tibble(.y$cast)

    if (!"name" %in% names(cast_df)) return(NULL)

    cast_df %>%
      select(actor_id = id, actor_name = name) %>%
      mutate(movie_id = .x)
  }
)


```

## Section Two
```{r}

write.csv(movies_df1, "movie", row.names = FALSE) # This is writing the data frame that was pulled from the package to a csv for easy access for everyone in the group.

movies <- read.csv("movie")  

movies
```


```{r}
write.csv(actor_movie_edges, "actor1", row.names = FALSE)

actor <- read.csv("actor1") %>% # Here we renamed the column to match with the data frame movies to allow for a join based on id.
  rename(id = movie_id)

actor

```

```{r}

movies <- movies %>% # This ensures that there are no duplicates and keeps only one row per movie. 
  distinct(id, .keep_all = TRUE)


actor_movies <- actor %>% # Here we did a left join to join the movies data set onto the actor data set based on the movie id. R prompted us to set the relationship to "many-to-many". 
  left_join(movies, by = "id", relationship = "many-to-many")


```

## Section Three
```{r student3 - Riley}


```

```{r}
library(igraph)

actor_graph <- graph_from_data_frame(actor_movies[, c("actor_name", "id")], directed = FALSE)

```

```{r}
connect_to_mark <- function(actor) {
  p <- shortest_paths(actor_graph, actor, "Mark Wahlberg")$vpath[[1]]
  if (length(p) == 0) return("No connection found.")

  nodes <- names(p)

  path <- sapply(nodes, function(x)
    if (x %in% actor_movies$id) actor_movies$title[actor_movies$id == x][1] else x
  )

  movie_count <- sum(path %in% actor_movies$title)

  list(
    path = unname(path),
    movies = movie_count
  )
}


```

```{r}
connect_to_mark("Jason Momoa")
```
```{r}
connect_to_mark("Kevin Hart")
```

```{r}
connect_to_mark("Jennifer Aniston")
```

```{r}
connect_to_mark("Kevin Bacon")
```

