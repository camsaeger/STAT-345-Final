---
title: "Super Awesome Project Template"
output: word_document
date: "2023-03-31"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Section One

```{r student1 - Cam, warning=FALSE}
library(igraph)
library(rvest)
library(tidyverse)
```


```{r}

### Creating Movies Database

library(TMDb)
library(dplyr)

api_key <- "17dccb4de2aa1a7bf742763a8dc633be" # This is our API key that allows us to use the package that we installed to gather data from. 


movies <- discover_movie(
  api_key     = api_key,
  with_genres = 28,             
  primary_release_year = "2000"
)

movies_list <- movies$results

years <- as.character(2000:2024)

get_year_movies <- function(year_str) {

  first <- discover_movie(
    api_key = api_key,
    with_genres = 28,
    primary_release_year = year_str,
    page = 1
  )

  total_pages <- min(first$total_pages, 500)

  map_df(1:total_pages, ~ {
    Sys.sleep(0.25) 
    discover_movie(
      api_key = api_key,
      with_genres = 28,
      primary_release_year = year_str,
      page = .x
    )$results
  })
}

movies_all <- map_df(years, get_year_movies)

```


```{r}

### Filtering Movies Data Frame                

movies_df1 <- movies_all %>% 
  select(id, title, popularity, release_date)

movies_df1 <- movies_df1 %>%
  filter(
    release_date >= as.Date("2010-01-01"),
    release_date <= as.Date("2020-12-31")
    )
# Here we took movies_all and only selected movie id, movie title, movie popularity, and movie release date. We then filtered it to only include movies that were released from 2010 to 2020. We chose this because of the amount of the data that was pulled in from this package. With this time frame we had 11,370 movies to work with. 
  
```


```{r}

### Creating Data Set of Edges Of Movies

library(purrr)
library(tibble)
library(tidyr)

safe_credits <- function(x) movie_credits(api_key, x)   #This is just using the api key we got.

credits_list <- map(movies_df1$id, safe_credits)      #This is the list of the movie credits

#This is making the edges of the actor and movie dataframe
actor_movie_edges <- map2_df(
  movies_df1$id,
  credits_list,
  ~ {
    if (is.null(.y)) return(NULL)
#This is making the cast list a tibble
    cast_df <- tibble::as_tibble(.y$cast)

    if (!"name" %in% names(cast_df)) return(NULL)
#This makes the dataframe with the actor id, actor name, and movie id 
    cast_df %>%
      select(actor_id = id, actor_name = name) %>%
      mutate(movie_id = .x)
  }
)


```

## Section Two
```{r}

### Creating CSV Files (1)

write.csv(movies_df1, "movie", row.names = FALSE) # This is writing the data frame that was pulled from the package to a csv for easy access for everyone in the group.

movies <- read.csv("movie")  

movies
```


```{r}

### Creating CSV Files (2)

write.csv(actor_movie_edges, "actor1", row.names = FALSE)

actor <- read.csv("actor1") %>%
  rename(id = movie_id)
# Here we renamed the column to match with the data frame movies to allow for a join based on id.
actor

```

```{r}

### Joining Data Frames

movies <- movies %>% # This ensures that there are no duplicates and keeps only one row per movie. 
  distinct(id, .keep_all = TRUE)


actor_movies <- actor %>% # Here we did a left join to join the movies data set onto the actor data set based on the movie id. R prompted us to set the relationship to "many-to-many". 
  left_join(movies, by = "id", relationship = "many-to-many")


```



```{r}

### Creating Actor Graph

actor_graph <- graph_from_data_frame(actor_movies[, c("actor_name", "id")], directed = FALSE)
#This is creating the graph from the dataframe.

```

```{r}

### Creating Connection To Mark Function

connect_to_mark <- function(actor) {
  p <- shortest_paths(actor_graph, actor, "Mark Wahlberg")$vpath[[1]]               #This is finding the shortest path from an input actor and connecting it back to Mark Wahlberg
  if (length(p) == 0) return("No connection found.")    #This is saying if there is no path to Mark Wahlberg then it will give an output saying "No connection found."

  nodes <- names(p)
#This replaces the movie id with the movie names
  path <- sapply(nodes, function(x)
    if (x %in% actor_movies$id) actor_movies$title[actor_movies$id == x][1] else x
  )
#This adds how many movies it took to connect back to Mark Wahlberg
  movie_count <- sum(path %in% actor_movies$title)
#This prints the path including actors and how many movies it took
  list(
    path = unname(path),
    movies = movie_count
  )
}


```

```{r}

### Testing Our Function

#This is testing the function
connect_to_mark("Jason Momoa")
connect_to_mark("Kevin Hart")
connect_to_mark("Jennifer Aniston")
connect_to_mark("Kevin Bacon")
```


```{r - Cam, warning=FALSE}

### Descriptive Statistics

library(ggplot2)

#This is collecting the shortest paths to Mark Wahlberg
wahlberg_distances <- distances(
  actor_graph,
  v = V(actor_graph),
  to = "Mark Wahlberg"
)

#This converts the previous distances into a data frame
wahlberg_df <- data.frame(
  actor = rownames(wahlberg_distances),
  wahlberg_number = as.numeric(wahlberg_distances[,1])
)

#This removes the actors who are not connected to Mark Wahlberg.
wahlberg_df_connected <- wahlberg_df %>%
  filter(is.finite(wahlberg_number))

#This generates the summary statistics.
summary(wahlberg_df_connected$wahlberg_number)

#This shows the distribution in a bar graph.
ggplot(wahlberg_df_connected, aes(x = wahlberg_number)) +
  geom_bar(fill = "blue") +
  labs(
    title = "Distribution of Wahlberg Numbers",
    x = "Wahlberg Number (distance from Mark Wahlberg)",
    y = "Number of actors"
  ) +
  theme_minimal()


```
```{r}



```


```{r - Bryce}



```

```{r}



```

